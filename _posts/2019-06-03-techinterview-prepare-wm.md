---
layout: post
title:  "기술면접 준비하기"
subtitle:  "웍스모바일 면접 대비"
date:   2019-06-03 16:40:00 +0900
author:     "날도"
header-img: "img/post-bg-2015.jpg"
mathjax: true
catalog: true
tags: 
    - 낙서장
    - 기술면접
    - 면접
---

그저께랑 어제 자료구조와 알고리즘을 정리하는데, 이미 알고있는 것을 정리하는 거라 간단할 줄 알았는데 생각보다 그렇지 않았다. 오래되서 기억이 잘 안나서 그렇거나, 원래 잘 모르는 것일수도..<br>
아무튼 머리에 쥐날거 같은데 계속 알고리즘 정리하는 것보단, 잠시 환기 차원에서 **(주)웍스모바일** 의 면접 후기 등을 찾아보고, 남은 4일동안 공부해 가야할 것을 정리해야겠다.<br>

우선 각종 사이트에서 찾아본 웍스모바일 면접 후기에서는 아래와 같은 질문들을 했다고 한다.

* 자기소개
  * 나의 장점, 단점
* 자료구조
  * 손 코딩
  * 의사코드(pseudo-code)
* 알고리즘
  * 손 코딩
  * 의사코드(pseudo-code)
* 프로그래밍 지식 (소프트웨어 공학)
  * 가장 자신있는 언어
  * 특히 Java 의 데이터 타입(Array, ArrayList, LinkedList, Map, HashMap 등)과 그 외 전반적인 지식
  * MVC 구조란?
  * DTO, DAO, VO?
  * Restful 이란?
  * 젠킨스란?
  * 재귀
  * 로우 레벨 지식
  * OOP, AOP, FOP 등 프로그래밍 기법
  * 개발 방법론
* 운영체제
  * 멀티 스레드 지식 (환경 구성 시 신경써야 하는 부분 등) 
  * 스레드와 프로세스 차이
  * 동기, 비동기, 블로킹, 넌블로킹 차이
  * CPU 스케줄링
  * 프로세스 공간
* 데이터베이스
  * 쿼리 속도 및 효율 향상법
  * 정규화
  * 인덱스
  * 로우 레벨 지식
* HTTP 등 웹과 통신 지식
  * 주소창에 URL을 치고 엔터를 치면 흐름이 어떻게 되는가
  * HTTP/HTTPS 차이
  * CORS 이슈
  * OSI 7 계층 존재 이유
  * 로우 레벨 지식
* 컴퓨터 아키텍쳐
  * 32비트, 64비트 차이
* 디자인 패턴
* 개인 프로젝트 경험
  * 진행하면서 어려웠던 점이 뭐고, 어떻게 극복했는 지? 사례 포함
* 수업 경험
  * 가장 재밌었거나 기억나는 과목
* 그 밖에 꼬리물기 식 질문이 많음

이 이외에, 핵데이 당시 멘토님의 조언은 다음과 같다.

* 기본적인 것들을 착실히 공부해서 준비하라.
* 시간복잡도 등 알고리즘 효율 생각하라.
* Hackday 신청 당시 제출했던 자소서 기반으로 면접 준비하라.
* Hackday 당시 진행했던 프로젝트 경험, 느낀 점 및 부족했던 점 보완해라.
* GIF 만들기 프로젝트였던 만큼, 이미지 지식을 보충해서 가라.

추가로, 후기에서 말하고 있거나, 개인적으로 느낀 면접 TIP으로는 다음과 같다.

* 당연한 말이지만, 위축되지 않고 당당한 자세
* 과장되지 않고, 솔직하게 답변
* 모르는 것은 모른다고 말하며, 면접관을 속이려 들지 말 것
* 꼬리물기 식 질문이 많다고 하니, 답변을 추상적으로 하지 말고 구체적으로 하며, 잘 아는 쪽으로 답변할 것
(즉, 질문 유도가 가능하다!)
* 면접관이 꼰대 개발자일 수 있다. 이에 맞춰서 준비할 것<br>
(여기서 말하는 꼰대는 나쁜 뜻이 아니다. 자신의 개발 주관이 철저한 개발자를 뜻한다. 오히려 난 개발자는 꼰대여야 한다고 생각한다. 왜냐면 자신의 뚜렷한 주관없이 개발을 하게 된다면, 코드가 들쑥날쑥, 이랬다저랬다 할 수 있기 때문. 그렇다고 의사소통을 안하려 한다면 곤란하겠지만..)
* 일본어가 약간 되는걸 어필하자???
* 여러개를 짧게 답하는 것보다, 하나를 깊게 답하는게 나을듯

여기까지가 공부해야 할 점 정리였고, 아래는 실제 내용 정리이다.

## 자기소개
자기소개를 외워갈 필요는 없지만(있나?), 포함시켜야 할 점들을 정리하였다.

* 서론 : 인사말, 자신을 표현
* 본론 : 자신의 강점 어필
* 결론 : 본론에서 언급한 강점이 어떻게 회사에 도움이 되는지 어필, 끝맺음
* 자소서에 있는 내용을 활용, 키워드로 분명하고 확고하게 소개, 나만 해본 것을 키워드로 선정
* 자신의 강점과 회사의 주력 제품의 일치성 어필

예시1) 안녕하십니까! 웍스모바일에 지원하게 된 재활용의 달인, 박현국입니다. 왜 제가 재활용의 달인이냐면, 버려졌거나 공공으로 사용가능한 기자재, 오픈소스 및 API 등을 가져와 분석, 내 것으로 만든 후에 새로운 것을 만드는 것이 제 강점이기 때문입니다. 그 뿐만 아니라, 소스코드를 짤 때도 재활용이 가능하도록 하여 효율을 높이는 것에 높은 관심을 가지고 있습니다.
저는 이런 강점을 살려 몇 차례 프로젝트를 진행하였으며, 특히 올 해 진행한 저희 졸업작품의 경우 서버 컴퓨터는 저희 집의 오래된 컴퓨터를 재조립하여 사용하였고, 소스코드 또한 오픈소스를 분석하여 저희 프로젝트에 적용시킴으로써, 퀄리티 있는 웹 어플리케이션을 개발하였습니다. (제가 이런 강점을 가질 수 있는 것은, 하드웨어 및 소프트웨어의 이해도가 높은 편인 덕분이라고 자부합니다.) 만약 제가 라인 웍스나 기타 개발 업무에 투입이 된다면, 제 장점을 200% 활용할 수 있다고 확신합니다. 감사합니다.

예시2) 안녕하십니까! 웍스모바일에 지원하게 된 개발 벌레, 박현국입니다. 흔히 책을 즐겨 읽는 사람을 책벌레, 공부를 열심히 하는 사람을 공부벌레라고 하듯이, 저는 제 자신을 개발을 즐기면서 열심히 하는 개발 벌레라고 생각합니다. 
제가 생각하는 개발자로서의 제 강점은 대표적으로 세 가지입니다. 첫 번째 강점은 와인소프트라는 회사에서 인턴십을 통해 실무를 경험하며 다져진 정신력입니다. 둘째로는 크몽이라는 사이트에서 외주 작업을 하면서 얻게 된 사람과의 대화법입니다. 세번째로는 무엇보다도 개발이 즐겁습니다. 한 번 개발을 시작하게 되면, 누가 불러도 잘 듣지를 못합니다.
저는 이러한 강점을 웍스모바일에서 일하면서 살릴 수 있다고 생각합니다. 특히 라인 웍스나 기타 개발 업무에 투입이 된다면, 이러한 강점들을 200% 활용할 수 있다고 확신합니다. 감사합니다.

개인적으론 예시2가 더 맘에 든다.

## 프로젝트 경험
우선 개인적인 프로젝트 경험으로는 아래와 같이 말할 수 있다.

#### 와인소프트에서의 인턴
와인소프트는 자사 캐시서버 솔루션을 서비스하는 회사이다. 와인소프트에서 인턴을 진행하면서 프로젝트를 진행해 본 것은 아니지만, 나 자신의 개발자로서의 삶이 시작된 계기라고 볼 수 있다. 코딩은 약간 할 줄 알았지만, 개발에 대해선 무지했던 내가, 본격적으로 개발에 대해 공부하게 된 계기가 아닐까 한다. 당시 회사의 솔루션이 C/C++로 되어있었기 때문에, C를 사용한 저레벨의 코딩, 특히 포인터를 사용하여 코딩할 일이 많아서, 이때부터 동적할당과 해제에 대한 자신이 붙었던 것 같다. 또한 개발뿐만 아니라, 소프트웨어 공학, 통신 등에 대한 지식의 기본은 물론, 심화까지 깊게 공부할 수 있었다. 무엇보다 당시 인턴십을 하면서, 무엇을 할지 몰라 헤메다가 결국 나태해진 나 자신을 당시 소장님께서 보시면서 채찍질 해주셨던 것이 큰 변화였다. 와인소프트에서의 인턴십으로 인해, 나는 스스로 공부하는 법을 터득한 것이다. 면접때는 이 인턴십으로 내 개발자의 삶이 시작되었다는 것만 언급하면 좋을 것 같다.

#### 크몽에서의 외주
인턴십을 종료한 후에, 따로 아르바이트를 찾지 못한 나는 크몽이라는 외주 사이트에서 일을 받기 시작헀다. 사실 당시에도 코딩 이외에는 제대로 할 줄 아는 것이 없어서, 프로젝트 단위의 의뢰보다는, 그거보다 조금 작은, 대학교 과제 수준의 일거리만 받기 시작했다. 그렇게 작은 단위의 코딩 작업을 하다가, 이따금씩 소규모 졸업 프로젝트 등 좀 더 큰 프로젝트도 맡곤 했다. 이때 나는 고객의 응대와 협상 방법을 어느 정도 터득했던 것 같다. 크몽에서의 외주가 코딩 실력을 어느 정도 향상시켜주긴 했지만, 프로젝트 경험이라고 치긴 애매하니 패스.

#### 위드캣에서의 아르바이트
크몽에서 이따금씩 작업 받으면서, 학교 다니면서 하다가, 친구한테 웹개발 아르바이트 같이 해보겠냐 해서 하게 되었다. 그 친구의 교수님이 운영하시는 작은 회사에서 코딩 아르바이트를 하는 것이었는데, 페이도 괜찮았고, 무엇보다 학생임을 고려해서 재택근무도 가능했기 떄문에 안 할 이유는 없었다. 위드캣은 하청업체? 비슷한 것으로, 외주를 받아서 프로젝트를 작업하는 회사였다. 프로젝트 내용은 Spring 프레임워크를 사용, 프론트 페이지를 만드는 것 이었다(보다 자세하게 이야기하면 LMS라는 인강 사이트와 Taxroid라는 연말정산 자동계산 사이트였다). 프로젝트 시작 당시에는 Spring 프레임워크를 1도 몰랐었다. 공부자료랍시고 PDF파일 주긴 했었지만, 당장 과제하기도 바쁜 시점에 보고 공부할 여유는 없었다.. 그래서 주먹구구식으로 디버깅 돌려보면서 코드를 익혀나갔다. MVC라는 구조를 공부하게 된 건 그때였다. 보통 사람은 이론을 공부한 후에 실습을 진행하지만, 나는 어찌된 게 항상 실습을 먼저 해보고 이론을 익힌다 ㅡㅡ;;<br>
프로젝트를 진행하면서 가장 어려웠던 점은, 시니어 개발자 없이 초보 개발자들로만 진행되었다는 것이다. 그래도 나는 인턴십을 해본 경험이라도 있어서 코드리뷰의 필요성에 대해서 알지만, 아마 다른 팀원도 알았을 거라 생각하지만, 그 코드리뷰를 하지 않고 소스를 짜다보니, 결국 코드 컨벤션을 지키지 않는 등 소스가 개판이 되곤 해버렸다. 또한 GIT을 사용한 버전 관리도 당시 모두가 초보라, 남이 작업해놓은 것을 롤백(Roll-Back)해버린 경우도 심심치 않게 있었다. <br>
이렇게 총체적 난국임에도 불구하고, 대표님은 심한 상황 아니면 크게 신경쓰지 않는 눈치셨다 ㅡㅡ;; 그래도 나는 혼자서라도 코드 컨벤션 최대한 맞추고, 주석도 열심히 달며, 의사소통을 원활히 하려고 노력했다. 아르바이트생이였지만 정사원 급의 일을 하려고 노력했다. <br>
Spring을 사용한 개발을 하면서, 이번엔 웹에 대한 지식이 크게 늘었다. 특히나 Restful API를 사용할 일이 많았는데, 당시에는 쓰면서도 이게 Restful API라는것을 몰랐었다. 단지 JSON 형식으로 호출하는 API 정도로만 알았을 뿐. 위드캣에서의 아르바이트 덕분에, 웹 백엔드 개발 실력이 무척 오르게 되었다.

#### 졸업프로젝트
위드캣 아르바이트를 하면서 졸업 프로젝트 역시 시작하게 되었는데, 위드캣에서 경험했던 Spring 프레임워크를 사용하여 웹 어플리케이션을 만드는 프로젝트였다. 컨셉은 온라인 편집기, 툴 어플리케이션으로, 간단한 기능이 필요한 프로그램이라면 다운받지 않아도 웹 브라우저 상에서 사용이 가능한 사이트를 만드는 것이 목적이었다. 실제 필요한 편집기능이나 툴들에 사용되는 코드는 오픈소스를 활용하였고, 주로 우리가 작업했던 내용은 뷰와 컨트롤러 부분이었다. <br>
어려웠던 점은, 팀원 중 본격적인 개발 경험이 있는 것이 나 뿐이라는 것이었다 ㅡㅡ;; 아이디어 및 주제 선정, 개발환경 구성 등 내가 먼저 나서서 했고, 팀원들에게 이해시키는데 집중을 해야 했다. 개발 자체도 거의 대부분 내가 도맡아서 한 것 같다. 이제와서 생각해보면 그건 잘못되었다고 생각한다. 조금 힘들고 귀찮더라도, 팀원들에게 개발 비중을 좀 더 실어주어야 했다. 물론 진짜로 모든 개발을 내가 도맡아서 한 건 아니고, 오픈소스를 가져와 붙이는 작업이나 그래프를 그리는 등 프론트-엔드 쪽 일부를 개발하도록 하게 했다. 나름대로의 코드 리뷰도 진행하면서 말이다. 하지만 그 보다 Java Controller 부분을 내가 아는 선에서 가르쳐보고, 같이 고민해보고 개발했다면 더 좋았을 거라는 생각이 들었다. 그래서 프로젝트 막바지에서 PPT와 설계서를 만들 때, 현재 개발의 스펙과 구성을 놓고 고민하는 시간을 가지기도 했다. 

#### 네이버 핵데이
아마 가장 중요하다고 생각되는 네이버 핵데이 프로젝트 관련 경험이다. 일단 참가기는 이전에 포스팅에 썼으니, 이번엔 당시 진행했던 프로젝트에 집중하여 기술한다.<br>
이전 포스팅에서 다루었던 것 처럼, 프로젝트 내용은 Animated GIF 생성 및 제작 후 조회하는 서버를 개발하는 것으로, 웹 프론트와 코어서버를 나누어서 진행하였다. 나는 아르바이트 및 졸업프로젝트의 경험을 살려 웹 프론트를 개발하였고, 다른 두 팀원은 업로드 된 이미지들을 가지고 GIF파일을 생성하는 코어서버를 개발하는 것이었다. 핵데이 시작 전에 나는 웹 프론트 UI 초안을 완성한 상태였기 때문에, 어서 완성하고 코어서버를 도와줄 계획이었다.<br>
그러나 웹 프론트 제작도 생각보다 만만치 않았다. CORS 이슈 등 예상치 못한 문제들이 튀어나왔고, Restful 통신할 때 협의한 부분도 개발이 진행됨에 따라 계속 변동되기도 했고, Controller에서 JSON 형식으로 값 받을 때 매핑 에러가 나기도 했다. CORS얘기를 하자면, 이전 프로젝트를 하면서도 CORS 도메인 이슈 등을 겪긴 했어도 Spring에서 제공하는 자체 Annotation으로도 해결이 가능했었기에, 그 동안 진지하게 고민해 본 적은 없었다. 그러나 이번 프로젝트는 위에서 말한 웹 프론트 + 코어서버 구조에 아파치를 감싼 형태로 개발해서, 도메인이 다른 이슈가 발생한 것이다. 멘토님이 도와주시지 않으셨다면, 웹 프론트 자체를 완성하지 못했을 지도 모른다. 그 이외에도 UI를 맞게 수정하느라 시간이 많이 들었고, 설정파일을 활용하는 법을 아직 잘 모르고 시간이 부족했기에, 로컬과 배포환경설정의 구분이 제대로 이루어지지 않아 테스트하는데도 어려움을 겪었다(후반에는 거의 배포판에서 테스트했다..). 후에 YAML을 통한 설정이 쉽게 가능하다는 것을 알게 되었다. 혹은 젠킨스를 활용했거나..<br>
이번 프로젝트를 통해 느낀 점은, 이쯤 되어도 아직 우물 안의 개구리라는 것이다. 인턴십부터 시작해서 지금까지 경험이 그래도 꽤 쌓였다고 자부했지만, 아직 갈 길이 너무나도 멀다. 머리로는 알고 있었지만 이번에 그걸 몸으로 깨달았다. 특히 아파치로 웹-코어 구조를 감싸는 형식을 이번에 처음 알았다. 이런 류의 프로젝트를 많이 해보는 것이 경험 면에서도, 포트폴리오 면에서도 큰 도움이 된다는 것을 다시 한 번 알았다.<br>
아쉬웠던 점은 코어서버 제작을 거의 참여하지 못했다는 것이다. 다른 두 팀원의 실력은 경쟁률을 뚫고 온 사람들 답게 출중했지만, 경험이 많지 않다 보니 코어서버 제작에도 난항을 겪었다. 내가 개발에 참여해서 셋이서 고민을 했다면, 이번 프로젝트를 완벽한 성공으로 이끌 수도 있지 않았을까 싶다.

추가) 스프링 프레임워크를 사용한 이유?<br>
네이버 핵데이 진행 시점에서는 가장 자신있는 프레임 워크였으며, 졸프때 사용한 이유는 제어의 역행을 지원하고, ORM을 지원하여 DB 데이터를 활용하기 쉬웠기 때문.

## 수업 경험
프로그래밍 수업이 개인적으로 가장 재밌었다. 어떤 프로그래밍 수업이든 다 재밌었는데, 특히 모바일 프로그래밍 과정에서 서버와 통신하는 부분 구현하면서 백엔드 개발의 재미를 소량이나마 깨달은 듯.

## 소프트웨어 공학
프로젝트 경험 다음으로 중요한 부분이 아닌가 생각한다.

#### 가장 자신있는 언어 : Java
사실 알고리즘 푸는데 있어서 가장 자신있는 언어는 파이썬이지만(제일 쉬우니까), 실 업무에서 가장 잘 쓸법한, 그리고 가장 많이 쓴 언어는 역시 자바이다. 손코딩 문제가 나오면 파이썬이나 자바로 풀 생각.

#### Java의 Collection
자바의 대표 Collection에는 List, Map, Set, Stack, Queue와 같은 것들이 있다. 이 추상화된 Collection 인터페이스 아래, 특정한 기법으로 구현된 자료구조가 들어간다. 예를 들어, List라는 인터페이스에는 구현방법에 따라 ArrayList가 들어갈 수도, LinkedList가 들어갈 수도 있다.

* List<br>
  * ArrayList<br>
    자바의 Vector를 개선한, 배열로 구현된 List이다. 그 말인 즉슨, 데이터가 저장된 순서가 같다는 말이다. 사실상 배열과 같은 자료구조이기 때문에, 리스트의 연산 자체의 수행시간 속도는 배열과 같다.
  * LinkedList<br>
    다음 노드의 주소를 기억하고 있는 List로, 배열에 비해 삽입과 삭제가 간단하다. 그러나 탐색의 경우 첫 번째 노드부터 탐색해 나가야 하기 때문에 느리다.
* Map<br>
  * HashMap<br>
    가장 일반적으로 사용하는 Map. HashTable을 사용, Key값에 해시함수를 적용하여 나온 index에 Value를 저장하는 식. 중복성을 허용하지 않으며, 순서가 없다는 것이 특징
  * TreeMap<br>
    Red-Black Tree 자료구조를 이용한 Map이다. Tree 구조이기 때문에 어느 정도 순서를 보장한다.
  * LinkedHashMap<br>
    LinkedList로 구현된 HashMap이다. List로 구현되어있기 때문에 순서가 보장된다. 하지만 LinkedList 특성상 랜덤 접근에서 느릴 수 있다.
* Set
  * HashSet<br>
    HashMap에서 Key값이 없는 자료형. 집합이라고 생각해도 무방하다. 값이 포함되어 있는지 아닌지만 관심이 있다. 순서를 보장하지 않으며, 중복값을 허용하지 않는다. Set중에는 가장 많이 사용된다.
  * TreeSet<br>
    Red-Black Tree 자료구조를 사용한 Set.
  * LinkedHashSet<br>
    LinkedList로 구현된 HashSet. 순서를 보장한다.
* Stack & Queue
  * Stack<br>
    직접 new 연산자로 객체를 생성하여 사용 가능.
  * Queue<br>
    LinkedList 에 new 연산자로 객체를 생성함으로서 사용 가능.

추가로 자바 Array와 ArrayList의 다른점.
둘 다 배열이라는 점은 동일하나, Array는 인덱스로 접근하는 반면, ArrayList는 메서드를 통해 접근한다(어짜피 Index로 호출한다는 점은 동일 하겠지만..). 또한 Array는 Object 뿐만 아니라 원시 형태(Primitive, 예를 들어 int, double 등)도 담을 수 있지만, Array는 Object형(Reference, 객체)만 담을 수 있다. 따라서 정수를 ArrayList에 넣을 경우 Integer형은 가능하지만 int형은 안 된다. 추가로, Integer처럼 int와 같은 원시타입을 담을 수 있는 객체를 Wrapper Class라고 한다.

#### OOP, AOP, FP
각각의 프로그래밍 기법에 대해 설명할 수 있어야 한다. 특히 OOP는 단골 질문이라 하니 중요.

* OOP (객체지향 프로그래밍) **(중요)**<br>
객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, **프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체** 로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법.
  * 장점
    * 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성 증가
    * 절차지향보다 유지보수가 간단
    * 클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합
  * 단점
    * 처리속도가 상대적으로 느리다.
    * 객체가 많으면 용량이 커진다.
    * 설계시 많은 노력과 시간이 필요하다.
  * OOP의 6가지 키워드
    * 클래스<br>
        현실 세계의 객체를 추상화시켜, 속성과 메서드로 정의한 것 (논리적 개념)
    * 인스턴스<br>
        클래스에서 정의한 것을 토대로 만든 실제 메모리상에 할당된 것, 실제 데이터
    * 추상화<br>
        객체지향 관점에서 클래스를 정의하는 것, 불필요한 정보 외 중요한 정보만 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙이는 것.
    * 캡슐화<br>
        코드를 수정없이 재활용 하는 것을 목적으로 함. 클래스라는 캡슐에 기능과 특성을 담아 묶는다. 목적을 기준으로 묶는다.<br>
        은닉화와의 차이 - 은닉화는 캡슐화의 일부라고 볼 수 있으며, 목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화.
    * 상속<br>
        클래스로부터 속성과 메서드를 물려받는 것을 말함. 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경
    * 다형성<br>
        하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있음. 대표적인 다형성이 오버라이딩과 오버로딩
  * OOP의 5가지 법칙 (SOLID)
    * Single Responsibility Principle, 단일 책임 법칙<br>
        각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 한다.
    * Open Close Principle, 개방 폐쇄 법칙<br>
        각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 한다.
        즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정한다.
    * Liskov Substitusion Principle, 리스코프 치환 법칙<br>
        자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 한다.
    * Interface Segreation Principle, 인터페이스 분리 법칙<br>
        각 행위에 대한 인터페이스는 서로 분리되어야 한다.
        핸드폰을 예로 들면, 전화를 하는데 핸드폰 카메라가 방해가 되면 안된다는 말.
    * Dependency Inversion Principle, 의존성 역전 법칙<br>
        상위 클래스가 하위 클래스에 의존하면 안된다는 법칙. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안된다.

* AOP (관점지향 프로그래밍)<br>
스프링 프레임워크의 핵심 요소 중 하나. 비즈니스 로직과 공통 모듈로 분리하고, 핵심 로직 사이사이에 공통 모듈을 잘 끼워 넣는 것을 말함. 이때 공통 모듈을 코드 밖에서 설정된다는 것이 핵심. 인증, 로깅, 트랜잭션 처리에 용이.

* FP (함수형 프로그래밍)<br>
함수형 프로그래밍은 선언형 프로그래밍으로, 어떻게(How)가 아닌 무엇(What)을 정의한다. C, Java등의 언어는 명령형 프로그래밍이며, 알고리즘을 기술하고 목적은 기술하지 않는다. 선언형은 반대로 알고리즘은 기술하지 않고 목적 위주로 기술하며, 데이터의 입력이 주어지고 데이터의 흐름을 추상적을 정의하는 방식.<br>

> 객체지향은 동작하는 부분을 캡슐화하여 이해를 돕고, 함수형은 동작하는 부분을 최소화하여 이해를 돕는다.

#### Stream API
Stream API가 뭔지 간략하게 정리하자.

SteamAPI는 Java의 Collection에서의 연속된 데이터의 반복 연산을 for문 등을 쓰지 않고, 추상화된 메서드를 통해 무엇(What)을 할 것인지 정의. 즉 FP이다. 스트림을 생성하는 최초연산, 중간의 로직을 구성하는 중간연산, 결과물을 처리하는 최종연산으로 나뉜다. 중간연산의 리턴값은 스트림으로, 계속해서 메서드 체이닝을 해 나갈 수 있다. 최종연산의 리턴값은 스트림이 아니며, 최종연산이 수행되지 않는다면 중간연산 역시 수행되지 않는다.

#### MVC 구조란?
정의, 동작 원리 등 알아두면 좋을 것 같다.

모델-뷰-컨트롤러의 약자로, 디자인 패턴의 하나이다. 비즈니스 처리 로직과 사용자 인터페이스를 구분시켜 서로 영향없이 개발이 가능하다는 장점이 있다(MVC패턴).<br>

모델(Model)은 어플리케이션이 "무엇"을 할 지에 대한 정의한다. 처리되는 데이터, 데이터베이스, 내부 알고리즘 등 내부 비즈니스에 관한 로직의 처리를 수행한다. 즉 사용자에게 보이지 않는 로직.

뷰(View)는 말 그대로 사용자에게 보여지는 영역이다. JSP등 사용자 인터페이스를 담당한다.

컨트롤러(Controller)는 모델에게 "어떻게"할 것인지를 알려주며, 모델과 뷰 사이를 연결하는 역할을 한다. 사용자의 입출력을 받아 데이터를 처리한다.

#### 스프링 지식
프로젝트에서 사용했기 때문에, 물어볼 가능성 충분

스프링 MVC에서의 컴포넌트<br>
View - Jsp, Controller - Java Class, Model - JavaBean<br>

컨테이너란?<br>
프레임워크 안에서 인스턴스들의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 부여한다. 내가 작성한 코드의 처리과정을 컨테이너에서 수행한다. 스프링 컨테이너는 스프링 프레임워크 핵심에 위치하여, DI를 통해 애플리케이션을 구성하는 컴포넌트들을 관리한다.

**IOC** 란?<br>
Inversion Of Control, 제어의 역행이라는 뜻으로, 인스턴스의 생성 및 소멸을 개발자 대신 스프링 컨테이너가 한다. 그외 제어권을 프레임워크에서 가져간다는 말로도 쓰인다.

**DI** 란?<br>
Dependency Injection, 의존성 주입이라는 뜻으로, IOC를 실제로 구현하는 방법. 의존성이 있는 컴포넌트를 개발자가 코드로 명시하는 것이 아니라 Spring이 런타임에서 연결해 처리해준다. XML파일을 통해 설정한대로, Bean객체 생성시 의존성 주입을 수행한다.

흐름(웹브라우저에서 Spring MVC로 요청했을 떄)<br>
요청된 URL을 dispatcher-servlet에 전달 -> 핸들러 매핑(매핑 핸들러가 아닌듯)은 해당 URL에 매핑된 컨트롤러가 있는지 검사 후 컨트롤러에 전달 -> 해당 컨트롤러가 로직을 처리 -> 결과를 ModelAndView 객체 생성 후 담아 dispatcher-servlet에 전달 -> dispatcher-servlet은 전달 받은 View(jsp)가 있는지 검사하기 위해 ViewResolver로 보냄 -> ViewResolver는 받은 View(jsp)가 있는 지 검사 후 View로 보냄 -> View에서 Model과 같이 View(jsp)를 그린 후에 dispatcher-servlet으로 전달 -> 최종적으로 컨텐츠를 클라이언트에게 전달.

**Bean** 객체란?<br>
자바에서의 POJO(Plain Old Java Object)로, XML 설정파일을 통한 생명주기, 종속성 등의 메타데이터를 가지고 스프링 컨테이너에서 생성된 객체이다. 컨테이너에서 생성되었다는 점을 제외하면 일반 자바객체와 같다.

#### DTO, DAO, VO 용어 정리
애매하게만 알고 있었는데 이번 기회에 정리하자.

**VO** 란?<br>
Value Object의 줄임말로, 값을 갖고있는 객체이다. 비즈니스 값을 가져올 때 사용하며, 보통 값을 수정할 수 없는 것으로 한다. DTO와 혼용해서 쓰기도 한다.

**DTO** 란?<br>
Data Transfer Object의 줄임말로, VO와 같이 값을 갖고 있는 객체이다. VO와의 차이점은 DB로 치자면 하나의 인스턴스로, 데이터 핸들링에 사용되는 객체이다. DTO를 통해 데이터를 전달할 수 있다.

**DAO** 란?<br>
Data Access Object의 줄임말로, 실제 DB에 접속하는 객체이다. Service와 DB사이에서 가져온 데이터를 엔티티로 변환시켜 가져온다. 대부분의 CRUD API를 제공한다.

#### Restful 이란?
이번 기회에 정의를 명확히 하고 가자. 자소서에도 언급했기 때문에 준비해야 함.

REST란 REpresental State Transfer의 약자, 자원을 표현하여 상태를 전달한다는 뜻으로, 웹에 있는 자원을 HTTP를 통하여 직관적으로 전달하기 위한 간단한 인터페이스이다. Restful API는 대부분의 데이터를 JSON형식이나 XML형식을 담아서 HTTP 프로토콜 위에서 통신하는 API 인 것이다.<br>
Restful 하다는 것은 REST 법칙에 통과한 것을 말하는데, 그 법칙은 다음과 같다.

1. 자원
2. 메소드(Method: GET, POST, PUT, DELETE)만으로 표현
3. 동사말고 명사만
4. 확장자는 포함하지 않음

즉 'naldo'라는 사용자를 찾는 URL 메서드를 설계할 때, Restful하다고 할 수 있는 예시는<br>
/users/naldo (GET)<br>
가 될 것이다.

메서드 종류 : <br>
GET : 조회<br>
POST : 추가<br>
PUT : 수정<br>
DELETE : 삭제<br>

이런 메서드를 CRUD 연산과 연결지어서 사용 가능 (Create, Read, Update, Delete)

#### AJAX란?
Ajax란 좁은 의미로 클라이언트에서 서버가 비동기적으로 통신하는 기술<br>
HTTP 요청 시 XMLHttpRequest라는 객체를 생성하여 수행한다.<br>

request요청의 상태가 변할 때, readyState라는 플래그가 변하며, onreadystatechange라는 함수를 호출하게 된다.<br>
readyState 상태 플래그<br>
0 : 객체 생성 완료, open()함수 호출 전<br>
1 : open()함수 호출 성공<br>
2 : send()함수 호출 성공<br>
3 : recv()함수 호출, 데이터 다운로드 중<br>
4 : Done, 모든 작업이 끝남

#### 개발 방법론
한 귀로 듣고 한 귀로 흘린 개발 방법론 간단하게 정리하자. 중요도 낮음.


## 운영체제
자소서에 Server-Side 프로그래밍을 잘한다고 큰소리 쳐버렸다.. 운영체제에 대해서 좀 더 깊게 공부해 가야겠다.

#### 프로세스와 스레드
**프로세스** 는 실행 중인 프로그램이다. 디스크에서 메모리로 적재되어, CPU 자원의 할당을 받을 수 있는 것을 말한다. 프로세스 에 할당되는 메모리 안에는 스택, 힙, 데이터, 코드 영역을 포함한다.

**PCB** 란 Process Control Block의 약자로, 프로세스 제어 블록이다. 프로세스에 대한 중요한 정보를 저장하고 있다. 운영체제가 프로세스를 표현한 것이라고도 한다. 프로세스 생성시 만들어지며, 주기억장치에 유지된다. 문맥전환 등 다른 프로세스를 처리해야 할 때, PCB에 현재 상태를 저장함으로써 나중에 그 작업 상태를 불러와 작업 재개가 가능해진다. PID, 상태, 다음 명령어 주소 등의 정보가 저장됨.

**PC** 란 Program Counter의 줄임말로, 다음에 실행될 명령어의 주소가 들어있는 레지스터이다. 명령어가 인출되면, 자동으로 다음 명령어를 가리키도록 주소값이 증가된다. 

**캐시메모리** 란 CPU의 레지스터와 메모리 사이에서, 캐싱을 통해 병목 현상을 완화하는 것을 말한다.

**스레드** 는 프로세스의 작업 실행 단위이다. 즉 멀티스레드라는 것은 한 프로세스 내에 여러개의 프로그램의 흐름을 말한다. 스레드간에는 프로세스의 주소나 자원을 공유할 수 있다. 스레드는 스레드 ID, PC, 레지스터 집합, 스택으로 구성된다. 스레드 간에는 각자 독립적으로 작업을 수행해야 하기 때문에, 각각 스택과 PC 레지스터를 받는다. 

#### 멀티 스레드 환경
하나의 프로세스에서 다수의 실행 단위로 구분하여 자원의 생성과 관리의 중복성을 최소화하여 효율을 높이는 것을 멀티 스레딩이라고 한다.

장점 : <br>
* 멀티 프로세스에 비해 메모리와 자원의 소모가 줄어든다. 
* 힙 영역을 사용하면 프로세스간 통신에 비해 스레드간 통신이 훨씬 간단하다.
* 스레드의 문맥전환은 캐시메모리를 비울 필요가 없어 프로세스의 문맥전환에 비해 더 빠르다.
* 그러므로, 시스템의 처리량이 늘며, 공간과 시간, 자원이 절약된다.

단점 : <br>
* 힙 영역을 공유하기 때문에, 해당 자원을 사용할 때 동기화를 해주어야 함.
* 동기화를 위해 과도한 락 사용시 병목 현상때문에 성능이 저하될 수 있음

멀티 스레드 VS 멀티 프로세스 <br>
이 두 가지는 실행 단위를 구분한다는 점은 같지만, 멀티 스레드는 자원을 덜 소모하는 대신 하나의 스레드가 비정상적인 오류를 일으키면 다른 스레드도 종료될 수가 있다는 점과 동기화 문제를 안고 있다. 멀티 프로세스는 자원을 공유하지 않기에 서로간 통신이 멀티 스레드보다 불편하고, CPU 자원을 더 많이 소모한다. 결국 상황에 맞게 골라서 써야한다.


#### 멀티 프로세싱과 멀티 프로그래밍 멀티 태스킹
CPU 코어의 관점에서 생각<br>
CPU 코어 여러개로 프로세스를 여러개 수행한다 -> 멀티 프로세싱
CPU 코어 하나로 프로세스를 여러개 수행한다 -> 멀티 프로그래밍
CPU 코어 몇 개를 쓰던 간에 작업을 수행한다 (프로세스보다 확장된 의미) -> 멀티 태스킹

#### 데드락
멀티 프로그래밍 환경에서 CPU와 같은 한정되고 공동된 자원을 사용할 때 데드락이 발생할 수 있다.<br>
예를 들어 프로세스 A가 자원 1을 사용 중인 상태에서 자원 2를 사용하려고 하지만 프로세스 B가 자원 2를 이미 사용하고 있어 대기중이다. 그런데 프로세스 B가 자원 2 사용을 끝내려면 자원 1이 필요한데, 프로세스 A가 이미 자원 1을 사용하고 있기 때문에 대기해야 한다. 즉 서로의 자원을 쓰고 싶은데 서로가 쓰지를 못하니 무한 대기상태가 걸리는데 이를 데드락, 교착상태라 한다.<br>

데드락의 발생 조건 4가지(모두 만족해야 함) :<br>
상호 배제 : 한 자원은 한 프로세스에 의해서만 사용됨, 두 개 이상 사용 불가<br>
점유 대기 : 프로세스는 자원을 가진 채 다른 자원을 기다릴 수 있음<br>
비선점 : 다른 프로세스가 사용 중인 자원을 강제로 가져올 수 없음<br>
순환 대기 : 프로세스의 집합에서, 각 프로세스는 순환적으로 다음 프로세스가 필요로 하는 자원을 가지고있다.<br>

데드락 해결법 : <br>
예방 : 4가지 조건 중 하나라도 만족되지 못하게 함<br>
회피 : 알고리즘을 데드락이 발생하지 않도록 적용<br>
회복 : 교착상태가 발생하면 그때 해결함<br>
무시 : 회복과정의 성능저하가 더 심하다면 그냥 무시함<br>

임계영역과 크리티컬 섹션


#### 컨텍스트 스위칭


#### 동기, 비동기, 블로킹, 넌블로킹 차이


#### CPU 스케줄링


## 데이터베이스
분야가 웹개발, 백엔드 개발인 만큼, 자세하지는 못해도 준수한 수준은 공부해 가야 한다. 깊게 공부하진 못할거 같은 예감.. 기사시험책을 참고해서 공부해야겠다.

#### 기본 용어

#### 쿼리 속도 및 효율 향상법

#### 정규화

#### 인덱스

## 웹과 통신
소프트웨어 공학과 동급으로 중요하다고 생각한다. 백엔드 개발인 만큼 웹으로 통신 해야하는 일이 많기 때문.

#### HTTP 요청 흐름

#### HTTP/HTTPS 차이

#### CORS 이슈

#### OSI 7 계층 및 TCP/IP 계층

#### TCP/UDP 등 로우레벨 통신 지식

#### 라우팅 테이블

#### 비트레이트 계산

#### 멀티파트 업로드
프로젝트 당시 업로드를 어떻게 업로드했는가?



## 디자인패턴
디자인 패턴의 정의 및 유명한 디자인 패턴 몇 가지 조사해 가면 좋을 듯 하다.

#### MVC 패턴
위 스프링 MVC 설명하면서 써놨다.

#### 싱글톤 패턴

## 이미지
이미지 공부도 안할 수 없다. 

## 리눅스 명령어
우선순위는 낮지만, 자소서에 리눅스가 자신 있다고 써놔서, 혹시나 해서..
